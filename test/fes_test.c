#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "libefex.h"

#define DEFAULT_BUFFER_SIZE 4096
#define DEFAULT_ADDRESS 0x40000000
#define WORK_MODE_USB_PRODUCT 0x10

struct boot_file_head_t {
    uint32_t jump_instruction; /* one intruction jumping to real code */
    uint8_t magic[8]; /* ="eGON.BT0" */
    uint32_t check_sum; /* generated by PC */
    uint32_t length; /* generated by LD */
    uint32_t pub_head_size; /* the size of boot_file_head_t */
    uint8_t pub_head_vsn[4]; /* the version of boot_file_head_t */
    uint32_t ret_addr; /* the return value */
    uint32_t run_addr; /* run addr */
    uint32_t boot_cpu; /* eGON version */
    uint8_t platform[8]; /* platform information */
};

struct uboot_base_head_t {
    uint32_t jump_instruction; /* one intruction jumping to real code */
    uint8_t magic[8]; /* ="u-boot" */
    uint32_t check_sum; /* generated by PC */
    uint32_t align_size; /* align size in byte */
    uint32_t length; /* the size of all file */
    uint32_t uboot_length; /* the size of uboot */
    uint8_t version[8]; /* uboot version */
    uint8_t platform[8]; /* platform information */
    uint32_t run_addr;
};

struct uboot_normal_gpio_cfg_t {
    uint8_t port; /* port : PA/PB/PC ... */
    uint8_t port_num; /* internal port num: PA00/PA01 ... */
    uint8_t mul_sel; /* function num: input/output/io-disalbe ...*/
    uint8_t pull; /* pull-up/pull-down/no-pull */
    uint8_t drv_level; /* driver level: level0-3*/
    uint8_t data; /* pin state when the port is configured as input or output*/
    uint8_t reserved[2];
};

struct uboot_data_head_t {
    uint32_t dram_para[32];
    int run_clock; /* Mhz */
    int run_core_vol; /* mV */
    int uart_port; /* UART ctrl num */
    struct uboot_normal_gpio_cfg_t uart_gpio[2]; /* UART GPIO info */
    int twi_port; /* TWI ctrl num */
    struct uboot_normal_gpio_cfg_t twi_gpio[2]; /* TWI GPIO info */
    int work_mode; /* boot,usb-burn, card-burn */
    int storage_type; /* 0:nand 1:sdcard 2:spinor */
    struct uboot_normal_gpio_cfg_t nand_gpio[32]; /* nand GPIO info */
    uint8_t nand_spare_data[256]; /* nand info */
    struct uboot_normal_gpio_cfg_t sdcard_gpio[32]; /* sdcard GPIO info */
    uint8_t sdcard_spare_data[256]; /* sdcard info */
    uint8_t secureos_exist;
    uint8_t monitor_exist;
    uint8_t func_mask; /* see enum UBOOT_FUNC_MASK_EN */
    uint8_t uboot_backup; /* use in OTA update */
    uint32_t uboot_start_sector_in_mmc; /*use in OTA update */
    int dtb_offset; /*device tree in uboot */
    int boot_package_size; /*boot package size, boot0 pass this value */
    uint32_t dram_scan_size; /*dram real size */
    int reserved[1]; /*reseved,256bytes align */
    /*expend boot_ext[0](int[4]) in uboot 2014*/
    uint16_t pmu_type;
    uint16_t uart_input;
    uint16_t key_input;
    uint8_t secure_mode; /*update by update_uboot*/
    uint8_t debug_mode; /*update by update_uboot*/
    int reserved2[2];
};


struct uboot_ext_head_t {
    int data[4];
};


struct uboot_head_t {
    struct uboot_base_head_t uboot_head;
    struct uboot_data_head_t uboot_data;
    struct uboot_ext_head_t uboot_ext[15];
    uint8_t hash[64];
};

static void usage(const char *prog_name) {
    printf("Usage: %s [-f file_to_download] [-u file_to_upload]\n", prog_name);
    printf("Options:\n");
    printf("  -f file   Download data from specified file to device\n");
    printf("  -u file   Upload data from device to specified file\n");
    printf("  No args   Run default test sequence\n");
}

int init_device_fes(struct sunxi_efex_ctx_t *ctx, const char *fex_file, const char *uboot_file) {
    int ret = 0;

    // Process FEX file
    if (fex_file) {
        FILE *fp = fopen(fex_file, "rb");
        if (!fp) {
            fprintf(stderr, "ERROR: Cannot open file %s for reading\r\n", fex_file);
            return -1;
        }

        // Get file size
        fseek(fp, 0, SEEK_END);
        const long file_size = ftell(fp);
        fseek(fp, 0, SEEK_SET);

        if (file_size <= 0) {
            fprintf(stderr, "ERROR: File %s is empty\r\n", fex_file);
            fclose(fp);
            return -1;
        }

        // Allocate buffer for file content
        char *buffer = malloc(file_size);
        if (!buffer) {
            fprintf(stderr, "ERROR: Memory allocation failed\r\n");
            fclose(fp);
            return -1;
        }

        // Read file content
        const size_t bytes_read = fread(buffer, 1, file_size, fp);
        fclose(fp);

        if (bytes_read != (size_t) file_size) {
            fprintf(stderr, "ERROR: Failed to read entire file\r\n");
            free(buffer);
            return -1;
        }

        const struct boot_file_head_t *fex_head = (const struct boot_file_head_t *) buffer;
        const uint32_t run_addr = fex_head->ret_addr;

        printf("Downloading %ld bytes from %s to device...\n", file_size, fex_file);
        sunxi_efex_fel_write_memory(ctx, run_addr, buffer, file_size);
        sunxi_efex_fel_exec(ctx, run_addr);
        free(buffer);

        printf("FEX file download completed successfully\n");
    }

    // Process U-Boot file
    if (uboot_file) {
        FILE *fp = fopen(uboot_file, "rb");
        if (!fp) {
            fprintf(stderr, "ERROR: Cannot open file %s for reading\r\n", uboot_file);
            return -1;
        }

        // Get file size
        fseek(fp, 0, SEEK_END);
        const long file_size = ftell(fp);
        fseek(fp, 0, SEEK_SET);

        if (file_size <= 0) {
            fprintf(stderr, "ERROR: File %s is empty\r\n", uboot_file);
            fclose(fp);
            return -1;
        }

        // Allocate buffer for file content
        char *buffer = malloc(file_size);
        if (!buffer) {
            fprintf(stderr, "ERROR: Memory allocation failed\r\n");
            fclose(fp);
            return -1;
        }

        // Read file content
        const size_t bytes_read = fread(buffer, 1, file_size, fp);
        fclose(fp);

        if (bytes_read != (size_t) file_size) {
            fprintf(stderr, "ERROR: Failed to read entire file\r\n");
            free(buffer);
            return -1;
        }

        struct uboot_head_t *uboot_head = (struct uboot_head_t *) buffer;
        uboot_head->uboot_data.work_mode = WORK_MODE_USB_PRODUCT;

        printf("Downloading %ld bytes from %s to device...\n", file_size, uboot_file);

        sunxi_efex_fel_write_memory(ctx, uboot_head->uboot_head.run_addr, buffer, file_size);
        sunxi_efex_fel_exec(ctx, uboot_head->uboot_head.run_addr);
        free(buffer);

        printf("U-Boot file download completed successfully\n");
    }

    sunxi_usb_exit(ctx);

    sleep(5);

    while (1) {
        ret = sunxi_scan_usb_device(ctx);
        if (ret > 0) {
            break;
        }
        sleep(1);
    }

    while (1) {
        printf("Device reconnected, try init in fes mode\n");
        sunxi_usb_init(ctx);
        sunxi_efex_init(ctx);
        if (ctx->resp.mode == DEVICE_MODE_SRV) {
            break;
        }
        sleep(3);
        sunxi_usb_exit(ctx);
        sunxi_scan_usb_device(ctx);
    }

    printf("Device reconnected and in FES mode!\n");

    return 0;
}

int main(const int argc, char *argv[]) {
    struct sunxi_efex_ctx_t ctx = {0};
    int ret = 0;
    const char *fex_file = NULL;
    const char *uboot_file = NULL;

    // Parse command line arguments
    for (int arg_index = 1; arg_index < argc; arg_index++) {
        if (strcmp(argv[arg_index], "-h") == 0 || strcmp(argv[arg_index], "--help") == 0) {
            usage(argv[0]);
            return 0;
        }
        if (strcmp(argv[arg_index], "-f") == 0) {
            if (arg_index + 1 < argc) {
                fex_file = argv[++arg_index];
            } else {
                fprintf(stderr, "Error: -f option requires a filename argument\n");
                usage(argv[0]);
                return -1;
            }
        } else if (strcmp(argv[arg_index], "-u") == 0) {
            if (arg_index + 1 < argc) {
                uboot_file = argv[++arg_index];
            } else {
                fprintf(stderr, "Error: -u option requires a filename argument\n");
                usage(argv[0]);
                return -1;
            }
        } else {
            fprintf(stderr, "Error: Unknown option '%s'\n", argv[arg_index]);
            usage(argv[0]);
            return -1;
        }
    }

    ret = sunxi_scan_usb_device(&ctx);
    if (ret <= 0) {
        fprintf(stderr, "ERROR: Can't get vaild EFEX device\r\n");
        return -1;
    }
    ret = sunxi_usb_init(&ctx);
    if (ret <= 0) {
        fprintf(stderr, "ERROR: EFEX device USB init failed\r\n");
        return -1;
    }
    ret = sunxi_efex_init(&ctx);
    if (ret < 0) {
        fprintf(stderr, "ERROR: EFEX device init failed\r\n");
        return -1;
    }

    printf("Found EFEX device\n");
    printf("Magic: %s\n", ctx.resp.magic);
    printf("ID: 0x%08x\n", ctx.resp.id);
    printf("Firmware: 0x%08x\n", ctx.resp.firmware);
    printf("Mode: 0x%04x\n", ctx.resp.mode);
    printf("Data Flag: 0x%02x\n", ctx.resp.data_flag);
    printf("Data Length: 0x%02x\n", ctx.resp.data_length);
    printf("Data Start Address: 0x%08x\n", ctx.resp.data_start_address);

    printf("Reserved: ");
    for (int i = 0; i < sizeof(ctx.resp.reserved); i++) {
        printf("%02x ", (uint8_t) ctx.resp.reserved[i]);
    }
    printf("\n");

    if (ctx.resp.mode == DEVICE_MODE_FEL) {
        init_device_fes(&ctx, fex_file, uboot_file);
    }

    uint32_t flash_type = 0;
    ret = sunxi_efex_fes_query_storage(&ctx, &flash_type);
    if (ret < 0) {
        fprintf(stderr, "ERROR: EFEX FES query storage failed\r\n");
        return -1;
    }
    printf("Storage Type: 0x%08x\n", flash_type);

    ret = sunxi_efex_fes_flash_set_onoff(&ctx, &flash_type, 0);
    if (ret != 0) {
        fprintf(stderr, "ERROR: EFEX FES flash set off failed\r\n");
        return -1;
    }
    printf("Flash Set Off\n");

    uint32_t flash_size = 0;
    ret = sunxi_efex_fes_probe_flash_size(&ctx, &flash_size);
    if (ret < 0) {
        fprintf(stderr, "ERROR: EFEX FES flash set off failed\r\n");
        return -1;
    }
    printf("Flash Size: 0x%08x\n", flash_size);

    ret = sunxi_efex_fes_flash_set_onoff(&ctx, &flash_type, 1);
    if (ret != 0) {
        fprintf(stderr, "ERROR: EFEX FES flash set on failed\r\n");
        return -1;
    }
    printf("Flash Set On\n");

    ret = sunxi_efex_fes_probe_flash_size(&ctx, &flash_size);
    if (ret < 0) {
        fprintf(stderr, "ERROR: EFEX FES flash set on failed\r\n");
        return -1;
    }
    printf("Flash Size: 0x%08x\n", flash_size);

    char down_buf[16] = "Hello, EFEX FES\0";
    ret = sunxi_efex_fes_down(&ctx, down_buf, 16, 0x40000000, SUNXI_EFEX_DRAM_TAG);
    if (ret < 0) {
        fprintf(stderr, "ERROR: EFEX FES download failed\r\n");
        return -1;
    }
    printf("Download data: %s\n", down_buf);

    char up_buf[16] = {0};
    ret = sunxi_efex_fes_up(&ctx, up_buf, 16, 0x40000000, SUNXI_EFEX_DRAM_TAG);
    if (ret < 0) {
        fprintf(stderr, "ERROR: EFEX FES upload failed\r\n");
        return -1;
    }
    printf("Upload Data: %s\n", up_buf);

    // maybe not supported
#if 0
    const uint8_t chip_id[129] = {0};
    ret = sunxi_efex_fes_get_chipid(&ctx, chip_id);
    if (ret < 0) {
        fprintf(stderr, "ERROR: EFEX FES get chipid failed\r\n");
        return -1;
    }
    printf("Chip ID: %s\n", chip_id);
#endif
}
