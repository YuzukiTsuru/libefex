#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "efex-common.h"
#if defined(_WIN32)
#include <windows.h>
#define sleep(x) Sleep(x * 1000)
#else
#include <unistd.h>
#endif

#include "libefex.h"

#define DEFAULT_BUFFER_SIZE 4096
#define DEFAULT_ADDRESS 0x40000000
#define WORK_MODE_USB_PRODUCT 0x10
#define	EFEX_CRC32_VALID_FLAG (0x6a617603)
#define MBR_VERSION 0x00000200
#define MBR_MAGIC "softw411"
#define PART_NAME_MAX_LEN (16)
#define PART_SIZE_RES_LEN (68)
#define MBR_tag_PARTITION_SIZE (128)
#define MBR_MAX_PART_CNT (120)
#define MBR_SIZE (16 * 1024)
#define MBR_RESERVED (MBR_SIZE - 32 - (MBR_MAX_PART_CNT * MBR_tag_PARTITION_SIZE))

struct boot_file_head_t {
	uint32_t jump_instruction; /* one intruction jumping to real code */
	uint8_t magic[8];          /* ="eGON.BT0" */
	uint32_t check_sum;        /* generated by PC */
	uint32_t length;           /* generated by LD */
	uint32_t pub_head_size;    /* the size of boot_file_head_t */
	uint8_t pub_head_vsn[4];   /* the version of boot_file_head_t */
	uint32_t ret_addr;         /* the run addr */
	uint32_t run_addr;         /* the return addr */
	uint32_t boot_cpu;         /* eGON version */
	uint8_t platform[8];       /* platform information */
};

struct dram_param_info_t {
	uint32_t dram_init_flag;
	uint32_t dram_update_flag;
	uint32_t dram_para[32];
};

struct uboot_base_head_t {
	uint32_t jump_instruction; /* one intruction jumping to real code */
	uint8_t magic[8];          /* ="u-boot" */
	uint32_t check_sum;        /* generated by PC */
	uint32_t align_size;       /* align size in byte */
	uint32_t length;           /* the size of all file */
	uint32_t uboot_length;     /* the size of uboot */
	uint8_t version[8];        /* uboot version */
	uint8_t platform[8];       /* platform information */
	uint32_t run_addr;
};

struct uboot_normal_gpio_cfg_t {
	uint8_t port;      /* port : PA/PB/PC ... */
	uint8_t port_num;  /* internal port num: PA00/PA01 ... */
	uint8_t mul_sel;   /* function num: input/output/io-disalbe ...*/
	uint8_t pull;      /* pull-up/pull-down/no-pull */
	uint8_t drv_level; /* driver level: level0-3*/
	uint8_t data;      /* pin state when the port is configured as input or output*/
	uint8_t reserved[2];
};

struct uboot_data_head_t {
	uint32_t dram_para[32];
	int run_clock;                                  /* Mhz */
	int run_core_vol;                               /* mV */
	int uart_port;                                  /* UART ctrl num */
	struct uboot_normal_gpio_cfg_t uart_gpio[2];    /* UART GPIO info */
	int twi_port;                                   /* TWI ctrl num */
	struct uboot_normal_gpio_cfg_t twi_gpio[2];     /* TWI GPIO info */
	int work_mode;                                  /* boot,usb-burn, card-burn */
	int storage_type;                               /* 0:nand 1:sdcard 2:spinor */
	struct uboot_normal_gpio_cfg_t nand_gpio[32];   /* nand GPIO info */
	uint8_t nand_spare_data[256];                   /* nand info */
	struct uboot_normal_gpio_cfg_t sdcard_gpio[32]; /* sdcard GPIO info */
	uint8_t sdcard_spare_data[256];                 /* sdcard info */
	uint8_t secureos_exist;
	uint8_t monitor_exist;
	uint8_t func_mask;                  /* see enum UBOOT_FUNC_MASK_EN */
	uint8_t uboot_backup;               /* use in OTA update */
	uint32_t uboot_start_sector_in_mmc; /*use in OTA update */
	int dtb_offset;                     /*device tree in uboot */
	int boot_package_size;              /*boot package size, boot0 pass this value */
	uint32_t dram_scan_size;            /*dram real size */
	int reserved[1];                    /*reseved,256bytes align */
	/*expend boot_ext[0](int[4]) in uboot 2014*/
	uint16_t pmu_type;
	uint16_t uart_input;
	uint16_t key_input;
	uint8_t secure_mode; /*update by update_uboot*/
	uint8_t debug_mode;  /*update by update_uboot*/
	int reserved2[2];
};

struct uboot_ext_head_t {
	int data[4];
};

struct uboot_head_t {
	struct uboot_base_head_t uboot_head;
	struct uboot_data_head_t uboot_data;
	struct uboot_ext_head_t uboot_ext[15];
	uint8_t hash[64];
};

/* clang-format off */
EFEX_PACKED_BEGIN
struct sunxi_partition_t {
	uint32_t addrhi;
	uint32_t addrlo;
	uint32_t lenhi;
	uint32_t lenlo;
	uint8_t classname[PART_NAME_MAX_LEN];
	uint8_t name[PART_NAME_MAX_LEN];
	uint32_t user_type;
	uint32_t keydata;
	uint32_t ro;
	uint8_t res[PART_SIZE_RES_LEN];
}EFEX_PACKED;
EFEX_PACKED_END

EFEX_PACKED_BEGIN
struct sunxi_mbr_t {
	uint32_t crc32;
	uint32_t version;
	uint8_t magic[8];
	uint32_t copy;
	uint32_t index;
	uint32_t PartCount;
	uint32_t stamp[1];
	struct sunxi_partition_t array[MBR_MAX_PART_CNT];
	uint8_t res[MBR_RESERVED];
}EFEX_PACKED;
EFEX_PACKED_END
/* clang-format on */

int init_device_fes(struct sunxi_efex_ctx_t *ctx, const char *fex_file, const char *uboot_file) {
	int ret = 0;

	// Process FEX file
	if (fex_file) {
		FILE *fp = fopen(fex_file, "rb");
		if (!fp) {
			fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_OPEN), fex_file);
			return EFEX_ERR_FILE_OPEN;
		}

		// Get file size
		fseek(fp, 0, SEEK_END);
		const long file_size = ftell(fp);
		fseek(fp, 0, SEEK_SET);

		if (file_size <= 0) {
			fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_SIZE), fex_file);
			fclose(fp);
			return EFEX_ERR_FILE_SIZE;
		}

		// Allocate buffer for file content
		char *buffer = malloc(file_size);
		if (!buffer) {
			fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
			fclose(fp);
			return EFEX_ERR_MEMORY;
		}

		// Read file content
		const size_t bytes_read = fread(buffer, 1, file_size, fp);
		fclose(fp);

		if (bytes_read != (size_t) file_size) {
			fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_READ));
			free(buffer);
			return EFEX_ERR_FILE_READ;
		}

		const struct boot_file_head_t *fex_head = (const struct boot_file_head_t *) buffer;

		struct dram_param_info_t dram_param_info = {
				.dram_init_flag = 0,
				.dram_update_flag = 0,
		};

		printf("Clear DRAM param area at 0x%08x\n", fex_head->ret_addr);
		ret = sunxi_efex_fel_write(ctx, fex_head->ret_addr, (const char *) &dram_param_info,
		                           sizeof(struct dram_param_info_t));
		if (ret != EFEX_ERR_SUCCESS) {
			fprintf(stderr, "ERROR: %s\n", sunxi_efex_strerror(ret));
			free(buffer);
			return ret;
		}

		printf("Downloading %ld bytes from %s to device...\n", file_size, fex_file);
		ret = sunxi_efex_fel_write(ctx, fex_head->run_addr, buffer, (ssize_t) file_size);
		if (ret != EFEX_ERR_SUCCESS) {
			fprintf(stderr, "ERROR: %s\n", sunxi_efex_strerror(ret));
			free(buffer);
			return ret;
		}
		ret = sunxi_efex_fel_exec(ctx, fex_head->run_addr);
		if (ret != EFEX_ERR_SUCCESS) {
			fprintf(stderr, "ERROR: %s\n", sunxi_efex_strerror(ret));
			free(buffer);
			return ret;
		}

		sleep(1);

		ret = sunxi_efex_fel_read(ctx, fex_head->ret_addr, (char *) &dram_param_info, sizeof(struct dram_param_info_t));
		if (ret != EFEX_ERR_SUCCESS) {
			fprintf(stderr, "ERROR: %s\n", sunxi_efex_strerror(ret));
			free(buffer);
			return ret;
		}

		printf("DRAM init flag: %u\n", dram_param_info.dram_init_flag);
		printf("DRAM update flag: %u\n", dram_param_info.dram_update_flag);
		for (size_t i = 0; i < 32; i++) {
			printf("DRAM param[%zu]: 0x%08x\n", i, dram_param_info.dram_para[i]);
		}

		if (dram_param_info.dram_init_flag == 1) {
			free(buffer);
			printf("DRAM init failed\n");
			return -1;
		}
		free(buffer);
		printf("FEX file download completed successfully\n");
	}

	// Process U-Boot file
	if (uboot_file) {
		FILE *fp = fopen(uboot_file, "rb");
		if (!fp) {
			fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_OPEN), uboot_file);
			return EFEX_ERR_FILE_OPEN;
		}

		// Get file size
		fseek(fp, 0, SEEK_END);
		const long file_size = ftell(fp);
		fseek(fp, 0, SEEK_SET);

		if (file_size <= 0) {
			fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_SIZE), uboot_file);
			fclose(fp);
			return EFEX_ERR_FILE_SIZE;
		}

		// Allocate buffer for file content
		char *buffer = malloc(file_size);
		if (!buffer) {
			fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
			fclose(fp);
			return EFEX_ERR_MEMORY;
		}

		// Read file content
		const size_t bytes_read = fread(buffer, 1, file_size, fp);
		fclose(fp);

		if (bytes_read != (size_t) file_size) {
			fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_READ));
			free(buffer);
			return EFEX_ERR_FILE_READ;
		}

		struct uboot_head_t *uboot_head = (struct uboot_head_t *) buffer;
		uboot_head->uboot_data.work_mode = WORK_MODE_USB_PRODUCT;

		printf("Downloading %ld bytes from %s to device...\n", file_size, uboot_file);

		ret = sunxi_efex_fel_write(ctx, uboot_head->uboot_head.run_addr, buffer, (ssize_t) file_size);
		if (ret != EFEX_ERR_SUCCESS) {
			fprintf(stderr, "ERROR: %s\n", sunxi_efex_strerror(ret));
			free(buffer);
			sunxi_usb_exit(ctx);
			return ret;
		}
		ret = sunxi_efex_fel_exec(ctx, uboot_head->uboot_head.run_addr);
		if (ret != EFEX_ERR_SUCCESS) {
			fprintf(stderr, "ERROR: %s\n", sunxi_efex_strerror(ret));
			free(buffer);
			sunxi_usb_exit(ctx);
			return ret;
		}
		free(buffer);

		printf("U-Boot file download completed successfully\n");
	}

	sunxi_usb_exit(ctx);

	sleep(5);

	while (1) {
		ret = sunxi_scan_usb_device(ctx);
		if (ret == EFEX_ERR_SUCCESS) {
			break;
		}
		sleep(1);
	}

	while (1) {
		printf("Device reconnected, try init in fes mode\n");
		ret = sunxi_usb_init(ctx);
		if (ret != EFEX_ERR_SUCCESS) {
			printf("USB init failed: %s\n", sunxi_efex_strerror(ret));
			sleep(3);
			sunxi_usb_exit(ctx);
			sunxi_scan_usb_device(ctx);
			continue;
		}

		ret = sunxi_efex_init(ctx);
		if (ret != EFEX_ERR_SUCCESS) {
			printf("EFEX init failed: %s\n", sunxi_efex_strerror(ret));
			sleep(3);
			sunxi_usb_exit(ctx);
			sunxi_scan_usb_device(ctx);
			continue;
		}

		if (ctx->resp.mode == DEVICE_MODE_SRV) {
			break;
		}

		sleep(3);
		sunxi_usb_exit(ctx);
		sunxi_scan_usb_device(ctx);
	}

	printf("Device reconnected and in FES mode!\n");

	return 0;
}

void dump_mbr_info(const struct sunxi_mbr_t *mbr) {
	printf("MBR Info:\n");
	printf("  CRC32: 0x%08x\n", mbr->crc32);
	printf("  Version: 0x%08x\n", mbr->version);
	printf("  Magic: %.8s\n", (char *) mbr->magic);
	printf("  Copy: %u\n", mbr->copy);
	printf("  Index: %u\n", mbr->index);
	printf("  PartCount: %u\n", mbr->PartCount);
	for (uint32_t i = 0; i < mbr->PartCount; i++) {
		const struct sunxi_partition_t *part = &mbr->array[i];
		printf("  Partition %u:\n", i);
		printf("    Name: %.16s\n", (char *) part->name);
		printf("    Classname: %.16s\n", (char *) part->classname);
		const uint64_t addr = ((uint64_t) part->addrhi << 32) | part->addrlo;
		const uint64_t len = ((uint64_t) part->lenhi << 32) | part->lenlo;
		printf("    Address: 0x%016llx\n", (unsigned long long) addr);
		printf("    Length: 0x%016llx\n", (unsigned long long) len);
		printf("    User Type: 0x%08x\n", part->user_type);
		printf("    Read-Only: %u\n", part->ro);
	}
}

int download_raw(const struct sunxi_efex_ctx_t *ctx, const char *buffer, const size_t file_size,
                 const enum sunxi_fes_data_type_t type) {
	int ret = 0;

	sunxi_efex_fes_down(ctx, buffer, (ssize_t) file_size, 0, type);
	const struct sunxi_fes_verify_resp_t verify_resp = {0};

	for (size_t i = 0; i < 5; i++) {
		printf("Verifying RAW download, attempt %zu...\n", i + 1);
		ret = sunxi_efex_fes_verify_status(ctx, type, &verify_resp);
		if (ret != EFEX_ERR_SUCCESS) {
			printf("RAW verification failed: %s\n", sunxi_efex_strerror(ret));
			break;
		}
		if (verify_resp.flag == EFEX_CRC32_VALID_FLAG) {
			printf("RAW get crc32 vaild flag\n");
			if (verify_resp.media_crc == 0) {
				printf("RAW verification successful\n");
			} else {
				printf("RAW verification failed with status: 0x%02x\n", verify_resp.media_crc);
			}
			break;
		}
		printf("RAW verification status: 0x%02x\n", verify_resp.flag);
	}

	return 0;
}

int download_raw_file(const struct sunxi_efex_ctx_t *ctx, const char *firmware_file,
                      const enum sunxi_fes_data_type_t type) {
	int ret = 0;
	char *full_firmware_path = NULL;
	FILE *fp = NULL;
	char *buffer = NULL;
	long file_size = 0;

	// Ensure firmware file has .fex extension
	const char *fex_ext = ".fex";
	const size_t firmware_len = strlen(firmware_file);
	const size_t ext_len = strlen(fex_ext);

	// Check if the file already has .fex extension
	if (firmware_len >= ext_len && strcasecmp(firmware_file + firmware_len - ext_len, fex_ext) == 0) {
		// File already has .fex extension, use it as is
		full_firmware_path = strdup(firmware_file);
	} else {
		// Add .fex extension
		full_firmware_path = (char *) malloc(firmware_len + ext_len + 1);
		if (!full_firmware_path) {
			fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
			return EFEX_ERR_MEMORY;
		}
		sprintf(full_firmware_path, "%s%s", firmware_file, fex_ext);
	}

	if (!full_firmware_path) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
		return EFEX_ERR_MEMORY;
	}

	printf("Downloading raw file: %s\n", full_firmware_path);

	// Open firmware file
	fp = fopen(full_firmware_path, "rb");
	if (!fp) {
		fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_OPEN), full_firmware_path);
		free(full_firmware_path);
		return EFEX_ERR_FILE_OPEN;
	}

	// Get file size
	fseek(fp, 0, SEEK_END);
	file_size = ftell(fp);
	fseek(fp, 0, SEEK_SET);

	if (file_size <= 0) {
		fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_SIZE), full_firmware_path);
		fclose(fp);
		free(full_firmware_path);
		return EFEX_ERR_FILE_SIZE;
	}

	// Allocate buffer for file content
	buffer = (char *) malloc(file_size);
	if (!buffer) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
		fclose(fp);
		free(full_firmware_path);
		return EFEX_ERR_MEMORY;
	}

	// Read file content
	const size_t bytes_read = fread(buffer, 1, file_size, fp);
	fclose(fp);

	if (bytes_read != (size_t) file_size) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_READ));
		free(buffer);
		free(full_firmware_path);
		return EFEX_ERR_FILE_READ;
	}

	// Download raw data using download_raw function
	printf("Downloading %ld bytes raw data to device...\n", file_size);
	ret = download_raw(ctx, buffer, file_size, type);

	// Free allocated resources
	free(buffer);
	free(full_firmware_path);

	return ret;
}

int download_firmware(const struct sunxi_efex_ctx_t *ctx, const char *firmware_file, const uint64_t address,
                      uint64_t file_size, const int erase_flag) {
	int ret = 0;
	char *full_firmware_path = NULL;
	FILE *fp = NULL;
	char *buffer = NULL;

	// Ensure firmware file has .fex extension
	const char *fex_ext = ".fex";
	const size_t firmware_len = strlen(firmware_file);
	const size_t ext_len = strlen(fex_ext);

	// Check if the file already has .fex extension
	if (firmware_len >= ext_len && strcasecmp(firmware_file + firmware_len - ext_len, fex_ext) == 0) {
		// File already has .fex extension, use it as is
		full_firmware_path = strdup(firmware_file);
	} else {
		// Add .fex extension
		full_firmware_path = (char *) malloc(firmware_len + ext_len + 1);
		if (!full_firmware_path) {
			fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
			goto cleanup;
		}
		sprintf(full_firmware_path, "%s%s", firmware_file, fex_ext);
	}

	if (!full_firmware_path) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
		goto cleanup;
	}

	printf("Using firmware file: %s\n", full_firmware_path);

	// Open firmware file
	fp = fopen(full_firmware_path, "rb");

	if (fp) {
		// Get file size if file exists
		fseek(fp, 0, SEEK_END);
		file_size = ftell(fp);
		fseek(fp, 0, SEEK_SET);

		if (file_size <= 0) {
			fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_SIZE), full_firmware_path);
			goto cleanup;
		}
	} else {
		printf("WARNING: File %s not found, using %llu zero-filled buffer\n", full_firmware_path, file_size);
	}

	// Allocate buffer for file content
	buffer = malloc(file_size);
	if (!buffer) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
		goto cleanup;
	}

	// Initialize buffer with zeros
	memset(buffer, 0, file_size);

	// If file exists, read its content (will overwrite part of the zero-filled buffer)
	if (fp) {
		const size_t bytes_read = fread(buffer, 1, file_size, fp);
		if (bytes_read != (size_t) file_size) {
			fprintf(stderr, "WARNING: Read %zu bytes, expected %llu bytes from %s\n",
			        bytes_read, file_size, full_firmware_path);
			// Continue with whatever was read, buffer is already zero-filled
		}
	}

	// If erase_flag is set, first download all 0xFF data
	if (erase_flag) {
		char *ff_buffer = malloc(file_size);
		if (!ff_buffer) {
			fprintf(stderr, "ERROR: Failed to allocate buffer for erase operation\r\n");
			goto cleanup;
		}

		// Fill buffer with 0xFF (all F's)
		memset(ff_buffer, 0xFF, file_size);

		printf("Erasing area with 0xFF data...\n");
		ret = sunxi_efex_fes_down(ctx, ff_buffer, (ssize_t) file_size, (uint32_t) address, 0);
		free(ff_buffer); // Free the erase buffer

		if (ret != EFEX_ERR_SUCCESS) {
			fprintf(stderr, "ERROR: Erase operation failed: %s\r\n", sunxi_efex_strerror(ret));
			goto cleanup;
		}
	}

	// Download actual firmware data
	printf("Downloading %llu bytes firmware %s to address 0x%016llx...\n",
	       file_size, full_firmware_path, (unsigned long long) address);
	ret = sunxi_efex_fes_down(ctx, buffer, (ssize_t) file_size, (uint32_t) address, 0);
	if (ret != EFEX_ERR_SUCCESS) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(ret));
		goto cleanup;
	}

	// Verify download status
	const struct sunxi_fes_verify_resp_t verify_resp = {0};
	ret = sunxi_efex_fes_verify_value(ctx, (uint32_t) address, (ssize_t) file_size, &verify_resp);
	if (ret != EFEX_ERR_SUCCESS) {
		printf("Firmware verification failed: %s\n", sunxi_efex_strerror(ret));
	} else if (verify_resp.flag == EFEX_CRC32_VALID_FLAG) {
		printf("Firmware download successful\n");
	} else {
		printf("Firmware verification status: 0x%02x\n", verify_resp.flag);
	}

cleanup:
	// Free all allocated resources
	if (fp) {
		fclose(fp);
	}
	if (buffer) {
		free(buffer);
	}
	if (full_firmware_path) {
		free(full_firmware_path);
	}
	return ret;
}

int main(const int argc, char *argv[]) {
	struct sunxi_efex_ctx_t ctx = {0};
	int ret = 0;
	const int erase_all = 1;

	ret = sunxi_scan_usb_device(&ctx);
	if (ret != EFEX_ERR_SUCCESS) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(ret));
		return ret;
	}
	ret = sunxi_usb_init(&ctx);
	if (ret != EFEX_ERR_SUCCESS) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(ret));
		sunxi_usb_exit(&ctx);
		return ret;
	}
	ret = sunxi_efex_init(&ctx);
	if (ret != EFEX_ERR_SUCCESS) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(ret));
		sunxi_usb_exit(&ctx);
		return ret;
	}

	printf("Found EFEX device\n");
	printf("Magic: %s\n", ctx.resp.magic);
	printf("ID: 0x%08x\n", ctx.resp.id);
	printf("Firmware: 0x%08x\n", ctx.resp.firmware);
	printf("Mode: 0x%04x\n", ctx.resp.mode);
	printf("Data Flag: 0x%02x\n", ctx.resp.data_flag);
	printf("Data Length: 0x%02x\n", ctx.resp.data_length);
	printf("Data Start Address: 0x%08x\n", ctx.resp.data_start_address);

	printf("Reserved: ");
	for (int i = 0; i < sizeof(ctx.resp.reserved); i++) {
		printf("%02x ", (uint8_t) ctx.resp.reserved[i]);
	}
	printf("\n");

	if (ctx.resp.mode == DEVICE_MODE_FEL) {
		init_device_fes(&ctx, "fes1.fex", "u-boot-efex.fex");
	}

	// Open MBR file in main function
	const char *mbr_file = "sunxi_mbr_nor.fex";
	FILE *fp = fopen(mbr_file, "rb");
	if (!fp) {
		fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_OPEN), mbr_file);
		sunxi_usb_exit(&ctx);
		return EFEX_ERR_FILE_OPEN;
	}

	// Get file size
	fseek(fp, 0, SEEK_END);
	const long file_size = ftell(fp);
	fseek(fp, 0, SEEK_SET);

	if (file_size <= 0) {
		fprintf(stderr, "ERROR: %s: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_SIZE), mbr_file);
		fclose(fp);
		sunxi_usb_exit(&ctx);
		return EFEX_ERR_FILE_SIZE;
	}

	// Allocate buffer for file content
	char *buffer = malloc(file_size);
	if (!buffer) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_MEMORY));
		fclose(fp);
		sunxi_usb_exit(&ctx);
		return EFEX_ERR_MEMORY;
	}

	// Read file content
	const size_t bytes_read = fread(buffer, 1, file_size, fp);
	fclose(fp);

	if (bytes_read != (size_t) file_size) {
		fprintf(stderr, "ERROR: %s\r\n", sunxi_efex_strerror(EFEX_ERR_FILE_READ));
		free(buffer);
		sunxi_usb_exit(&ctx);
		return EFEX_ERR_FILE_READ;
	}

	// Verify MBR file format (check magic number)
	const struct sunxi_mbr_t *mbr = (const struct sunxi_mbr_t *) buffer;
	if (memcmp(mbr->magic, MBR_MAGIC, sizeof(MBR_MAGIC) - 1) != 0) {
		fprintf(stderr, "ERROR: Invalid MBR file format\r\n");
		free(buffer);
		sunxi_usb_exit(&ctx);
		return -1;
	}

	// Print MBR information
	dump_mbr_info(mbr);

	if (erase_all) {
		uint32_t erase_info[4];
		erase_info[0] = 0x12;
		sunxi_efex_fes_down(&ctx, (const char *) erase_info, sizeof(erase_info), 0, SUNXI_EFEX_ERASE_TAG);
	}

	download_raw(&ctx, buffer, file_size, SUNXI_EFEX_MBR_TAG);

	for (uint32_t i = 0; i < mbr->PartCount; i++) {
		const struct sunxi_partition_t *part = &mbr->array[i];
		download_firmware(&ctx, (char *) part->name, part->addrlo | ((uint64_t) part->addrhi << 32),
		                  part->lenlo | ((uint64_t) part->lenhi << 32), 0);
	}

	free(buffer);

	download_raw_file(&ctx, "boot_package_nor.fex", SUNXI_EFEX_BOOT1_TAG);

	download_raw_file(&ctx, "boot0_spinor.fex", SUNXI_EFEX_BOOT0_TAG);

	sunxi_efex_fes_tool_mode(&ctx, TOOL_MODE_REBOOT, TOOL_MODE_REBOOT);

	// Free USB resources before exiting
	sunxi_usb_exit(&ctx);

	return 0;
}
